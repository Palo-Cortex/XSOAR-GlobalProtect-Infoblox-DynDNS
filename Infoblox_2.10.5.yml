commonfields:
  id: Infoblox_2.10.5
  version: -1
name: Infoblox_2.10.5
display: Infoblox_2.10.5
category: Network Security
image: data:image/png;base64,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
description: Infoblox enables you to receive metadata about IPs in your network and
  manages the DNS Firewall by configuring RPZs. It defines RPZ rules to block DNS
  resolution for malicious or unauthorized hostnames, or redirect clients to a walled
  garden by substituting responses.
detaileddescription: ' '
configuration:
- display: Server URL (e.g. https://example.net)
  name: url
  defaultvalue: https://example.net
  type: 0
  required: true
- display: User Name
  name: credentials
  defaultvalue: ""
  type: 9
  required: false
- display: Trust any certificate (not secure)
  name: insecure
  defaultvalue: "false"
  type: 8
  required: false
- display: Use system proxy settings
  name: proxy
  defaultvalue: ""
  type: 8
  required: false
script:
  script: |
    ''' IMPORTS '''
    from typing import Dict, Tuple, Optional, Union, Callable, Any
    import urllib3
    import json

    # Disable insecure warnings
    urllib3.disable_warnings()

    INTEGRATION_NAME = 'Infoblox Integration'
    INTEGRATION_COMMAND_NAME = 'infoblox'
    INTEGRATION_CONTEXT_NAME = 'Infoblox'
    REQUEST_PARAM_EXTRA_ATTRIBUTES = {'_return_fields+': 'extattrs'}
    REQUEST_PARAM_ZONE = {'_return_fields+': 'fqdn,rpz_policy,rpz_severity,rpz_type,substitute_name,comment,disable'}
    REQUEST_PARAM_CREATE_RULE = {'_return_fields+': 'name,rp_zone,comment,canonical,disable'}
    REQUEST_PARAM_LIST_RULES = {'_return_fields+': 'name,zone,comment,disable,type'}
    REQUEST_PARAM_SEARCH_RULES = {'_return_fields+': 'name,zone,comment,disable'}
    REQUEST_PARAM_PAGING_FLAG = {'_paging': '1'}

    RESPONSE_TRANSLATION_DICTIONARY = {
        '_ref': 'ReferenceID',
        'fqdn': 'FQDN',
        'rp_zone': 'Zone'
    }

    RPZ_RULES_DICT = {
        'Passthru': {
            'Domain Name': {
                'infoblox_object_type': 'record:rpz:cname'
            },
            'IP address': {
                'infoblox_object_type': 'record:rpz:a:ipaddress'
            },
            'Client IP address': {
                'infoblox_object_type': 'record:rpz:cname:clientipaddress'
            }
        },
        'Block (No such domain)': {
            'Domain Name': {
                'infoblox_object_type': 'record:rpz:cname'
            },
            'IP address': {
                'infoblox_object_type': 'record:rpz:cname:ipaddress'
            },
            'Client IP address': {
                'infoblox_object_type': 'record:rpz:cname:clientipaddress'
            }
        },
        'Block (No data)': {
            'Domain Name': {
                'infoblox_object_type': 'record:rpz:cname'
            },
            'IP address': {
                'infoblox_object_type': 'record:rpz:cname:ipaddress'
            },
            'Client IP address': {
                'infoblox_object_type': 'record:rpz:cname:clientipaddress'
            }
        },
        'Substitute (domain name)': {
            'Domain Name': {
                'infoblox_object_type': 'record:rpz:cname'
            },
            'IP address': {
                'infoblox_object_type': 'record:rpz:a:ipaddress'
            },
            'Client IP address': {
                'infoblox_object_type': 'record:rpz:cname:clientipaddressdn'
            }
        }
    }


    class Client(BaseClient):
        def __init__(self, base_url, verify=True, proxy=False, ok_codes=tuple(), headers=None, auth=None, params=None):
            super(Client, self).__init__(base_url, verify, proxy, ok_codes, headers, auth)
            self.params = params

        def _http_request(self, method, url_suffix, full_url=None, headers=None, auth=None, json_data=None, params=None,
                          data=None, files=None, timeout=10, resp_type='json', ok_codes=None, **kwargs):
            if params:
                self.params.update(params)
            try:
                return super()._http_request(method=method, url_suffix=url_suffix, full_url=full_url, headers=headers,
                                             auth=auth, json_data=json_data, params=self.params, data=data, files=files,
                                             timeout=timeout, resp_type=resp_type, ok_codes=ok_codes, **kwargs)
            except DemistoException as error:
                raise parse_demisto_exception(error, 'text')

        def test_module(self) -> Dict:
            """Performs basic GET request (List Response Policy Zones) to check if the API is reachable and authentication
            is successful.

            Returns:
                Response JSON
            """
            return self.list_response_policy_zones()

        def list_response_policy_zones(self, max_results: Optional[str] = None) -> Dict:
            """List all response policy zones.
            Args:
                    max_results:  maximum number of results
            Returns:
                Response JSON
            """
            suffix = 'zone_rp'
            request_params = assign_params(_max_results=max_results)
            request_params.update(REQUEST_PARAM_ZONE)
            return self._http_request('GET', suffix, params=request_params)

        def get_ip(self, ip: Optional[str]) -> Dict:
            """Get ip information.
            Args:
                ip: ip to retrieve.

            Returns:
                Response JSON
            """
            # The server endpoint to request from
            suffix = 'ipv4address'

            # Dictionary of params for the request
            request_params = assign_params(ip_address=ip)
            request_params.update(REQUEST_PARAM_EXTRA_ATTRIBUTES)
            return self._http_request('GET', suffix, params=request_params)

        def get_name(self, name: Optional[str]) -> Dict:
            """Get Name information.
            Args:
                name: name to retrieve.

            Returns:
                Response JSON
            """
            # The server endpoint to request from
            suffix = 'record:a'

            # Dictionary of params for the request
            request_params = assign_params(name=name)
            request_params.update(REQUEST_PARAM_EXTRA_ATTRIBUTES)
            return self._http_request('GET', suffix, params=request_params)

        def search_related_objects_by_ip(self, ip: Optional[str], max_results: Optional[str]) -> Dict:
            """Search ip related objects.
            Args:
                ip: ip to retrieve.
                max_results: maximum number of results

            Returns:
                Response JSON
            """
            # The server endpoint to request from
            suffix = 'search'

            # Dictionary of params for the request
            request_params = assign_params(address=ip, _max_results=max_results)
            return self._http_request('GET', suffix, params=request_params)

        def list_response_policy_zone_rules(self, zone: Optional[str], max_results: Optional[str],
                                            next_page_id: Optional[str]) -> Dict:
            """List response policy zones rules by a given zone name.
            Args:
                zone: response policy zone name.
                max_results: maximum number of results.
                next_page_id: ID of the next page to retrieve, if given all other arguments are ignored.

            Returns:
                Response JSON
            """
            # The server endpoint to request from
            suffix = 'allrpzrecords'
            # Dictionary of params for the request
            request_params = assign_params(zone=zone, _max_results=max_results, _page_id=next_page_id)
            request_params.update(REQUEST_PARAM_PAGING_FLAG)
            request_params.update(REQUEST_PARAM_LIST_RULES)

            return self._http_request('GET', suffix, params=request_params)

        def create_response_policy_zone(self, fqdn: Optional[str], rpz_policy: Optional[str],
                                        rpz_severity: Optional[str], substitute_name: Optional[str],
                                        rpz_type: Optional[str]) -> Dict:
            """Creates new response policy zone
            Args:
                fqdn: The name of this DNS zone.
                rpz_policy: The response policy zone override policy.
                rpz_severity: The severity of this response policy zone.
                substitute_name: The canonical name of redirect target in substitute policy.
                rpz_type: The type of rpz zone.
            Returns:
                Response JSON
            """

            data = assign_params(fqdn=fqdn, rpz_policy=rpz_policy, rpz_severity=rpz_severity,
                                 substitute_name=substitute_name, rpz_type=rpz_type)
            suffix = 'zone_rp'
            return self._http_request('POST', suffix, data=json.dumps(data), params=REQUEST_PARAM_ZONE)

        def delete_response_policy_zone(self, ref_id: Optional[str]) -> Dict:
            """Delete new response policy zone
            Args:
                ref_id: Zone reference id to delete.
            Returns:
                Response JSON
            """

            suffix = ref_id
            return self._http_request('DELETE', suffix)

        def create_rpz_rule(self, rule_type: Optional[str], object_type: Optional[str], name: Optional[str],
                            rp_zone: Optional[str], substitute_name: Optional[str],
                            comment: Optional[str] = None) -> Dict:
            """Creates new response policy zone rule.
            Args:
                rule_type: Type of rule to create.
                object_type: Type of object to assign the rule on.
                name: Rule name.
                rp_zone: The zone to assign the rule.
                substitute_name: The substitute name to assign (In case of substitute domain only)
                comment: A comment for this rule.
            Returns:
                Response JSON
            """
            canonical: Optional[str] = ''
            if rule_type == 'Passthru':
                canonical = 'rpz-passthru' if object_type == 'Client IP address' else name
            elif rule_type == 'Block (No data)':
                canonical = '*'
            elif rule_type == 'Substitute (domain name)':
                canonical = substitute_name

            data = assign_params(name=name, canonical=canonical, rp_zone=rp_zone, comment=comment)
            request_params = REQUEST_PARAM_CREATE_RULE
            suffix = demisto.get(RPZ_RULES_DICT, f'{rule_type}.{object_type}.infoblox_object_type')

            rule = self._http_request('POST', suffix, data=json.dumps(data), params=request_params)
            rule['result']['type'] = suffix
            return rule

        def update_host(self, host: Optional[str], ipadd: Optional[str], refid: Optional[str]) -> Dict:
            """Updates a host record.
            Args:
                host: FQDN to change
                ipadd: IP Address
                refid: Reference ID from Infoblox

            Returns:
                Response JSON
            """
            headers = {'content-type': 'application/json', 'Accept-Charset': 'UTF-8'}

            suffix = refid
            payload = '{"ipv4addr":"' + str(ipadd) + '"}'

            rule = self._http_request('PUT', suffix, headers=headers, data=payload)
            return rule

        def delete_host(self, refid: Optional[str]) -> Dict:
            """Deletes a host record.
            Args:
                refid: Reference ID from Infoblox

            Returns:
                Response JSON
            """
            headers = {'content-type': 'application/json', 'Accept-Charset': 'UTF-8'}

            suffix = "record:host/" + refid

            rule = self._http_request('DELETE', suffix, headers=headers)
            return rule

        def add_host(self, host: Optional[str], ipadd: Optional[str]) -> Dict:
            """Add a host record.
            Args:
                host: FQDN to change
                ipadd: IP Address

            Returns:
                Response JSON
            """
            suffix = "record:host"
            payload = '{ "name":"' + host + '","ipv4addrs":[{"ipv4addr":"' + str(ipadd) + '"}]}'
            headers = {'content-type': 'application/json', 'Accept-Charset': 'UTF-8'}

            rule = self._http_request('POST', suffix, headers=headers, data=payload)
            return rule

        def create_record(self, suffix: Optional[str], **kwargs: Union[str, int, None]) -> Dict:
            """Creates new record.
            Args:
                suffix: The infoblox object to be used as a url path.
                kwargs: A dict of arguments to be passed to the rule body. The following may appear:
                    - name
                    - rp_zone
                    - comment
                    - ipv4addr
                    - ipv6addr
                    - mail_exchanger
                    - preference
                    - order
                    - preference
                    - replacement
                    - ptrdname
                    - priority
                    - target
                    - weight
                    - port
                    - text
            Returns:
                Response JSON
            """
            request_data = {key: val for key, val in kwargs.items() if val is not None}
            request_params = {'_return_fields+': ','.join(request_data.keys()) + ',disable,name'}
            rule = self._http_request('POST', suffix, data=json.dumps(request_data), params=request_params)
            rule['result']['type'] = suffix
            return rule

        def create_substitute_record_rule(self, suffix: Optional[str], **kwargs: Union[str, int, None]) -> Dict:
            """Creates new response policy zone substitute rule.
            Args:
                suffix: The infoblox object to be used as a url path.
                kwargs: A dict of arguments to be passed to the rule body. The following may appear:
                    - name
                    - rp_zone
                    - comment
                    - ipv4addr
                    - ipv6addr
                    - mail_exchanger
                    - preference
                    - order
                    - preference
                    - replacement
                    - ptrdname
                    - priority
                    - target
                    - weight
                    - port
                    - text
            Returns:
                Response JSON
            """
            request_data = {key: val for key, val in kwargs.items() if val is not None}
            request_params = {'_return_fields+': ','.join(request_data.keys()) + ',disable,name'}
            rule = self._http_request('POST', suffix, data=json.dumps(request_data), params=request_params)
            rule['result']['type'] = suffix
            return rule

        def change_rule_status(self, reference_id: Optional[str], disable: Optional[bool]) -> Dict:
            """Changes a given rule status.
            Args:
                reference_id: Rule reference ID
                disable: true or false string
            Returns:
                Response JSON
            """
            request_data = assign_params(disable=disable)
            suffix = reference_id
            return self._http_request('PUT', suffix, data=json.dumps(request_data), params=REQUEST_PARAM_SEARCH_RULES)

        def get_object_fields(self, object_type: Optional[str]) -> Dict:
            """Retrieve a given object fields.
            Args:
                object_type: Infoblox object type
            Returns:
                Response JSON
            """
            request_params = {'_schema': object_type}
            suffix = object_type
            return self._http_request('GET', suffix, params=request_params)

        def get_refid(self,view: Optional[str], host: Optional[str], status: Optional[str]) -> Dict:
            """Retrieve a given object fields.
            Args:
                host: Host name to search for
                status: Search for either USED or UNUSED hosts
            Returns:
                Response JSON
            """

            headers = {'content-type': 'application/json', 'Accept-Charset': 'UTF-8'}
            payload = '{"view":"' + view + '","name":"' + host + '"}'
            request_params = {'name': host}
            suffix = "record:host"
            return self._http_request('GET', suffix, headers=headers, data=payload, params=request_params)

        def search_rule(self, object_type: Optional[str], rule_name: Optional[str],
                        output_fields: Optional[str]) -> Dict:
            """Search rule by its name
            Args:
                object_type: Infoblox object type
                rule_name: Full rule name
                output_fields: Fields to include in the return object
            Returns:
                Response JSON
            """
            request_params = assign_params(name=rule_name)
            if output_fields:
                request_params['_return_fields+'] = output_fields
            suffix = object_type
            return self._http_request('GET', suffix, params=request_params)

        def delete_rpz_rule(self, reference_id: Optional[str]) -> Dict:
            """Deletes a rule by its reference id
            Args:
                reference_id: Rule reference ID
            Returns:
                Response JSON
            """

            suffix = reference_id
            return self._http_request('DELETE', suffix)


    ''' HELPER FUNCTIONS '''


    def parse_demisto_exception(error: DemistoException, field_in_error: str = 'text'):
        err_msg = err_string = error.args[0]
        if '[401]' in err_string:
            err_msg = 'Authorization error, check your credentials.'
        elif 'Failed to parse json object' in err_string:
            err_msg = 'Cannot connect to Infoblox server, check your proxy and connection.'
        elif 'Error in API call' in err_string:
            err_lines = err_string.split('\n')
            infoblox_err = err_lines[1] if len(err_lines) > 1 else '{}'
            infoblox_json = json.loads(infoblox_err)
            err_msg = infoblox_json.get(field_in_error, 'text') if infoblox_json else err_string
        return DemistoException(err_msg)


    ''' COMMANDS '''


    def test_module_command(client: Client, *_) -> Tuple[str, Dict, Dict]:
        client.test_module()
        return 'ok', {}, {}


    def get_ip_command(client: Client, args: Dict[str, str]) -> Tuple[str, Dict, Dict]:
        """
        Args:
            client: Client object
            args: Usually demisto.args()

        Returns:
            Outputs
        """
        ip = args.get('ip')
        raw_response = client.get_ip(ip)
        ip_list = raw_response.get('result')

        # If no IP object was returned
        if not ip_list:
            return f'{INTEGRATION_NAME} - Could not find any data corresponds to: {ip}', {}, {}
        fixed_keys_obj = {RESPONSE_TRANSLATION_DICTIONARY.get(key, string_to_context_key(key)): val for key, val in
                          ip_list[0].items()}
        title = f'{INTEGRATION_NAME} - IP: {ip} info.'
        context = {
            f'{INTEGRATION_CONTEXT_NAME}.IP(val.ReferenceID && val.ReferenceID === obj.ReferenceID)': fixed_keys_obj}
        human_readable = tableToMarkdown(title, fixed_keys_obj, headerTransform=pascalToSpace)
        return human_readable, context, raw_response

    def get_name_command(client: Client, args: Dict[str, str]) -> Tuple[str, Dict, Dict]:
        """
        Args:
            client: Client object
            args: Usually demisto.args()

        Returns:
            Outputs
        """
        name = args.get('name')
        raw_response = client.get_name(name)
        host_list = raw_response.get('result')

        # If no IP object was returned
        if not host_list:
            return f'{INTEGRATION_NAME} - Could not find any data corresponds to: {name}', {}, {}
        fixed_keys_obj = {RESPONSE_TRANSLATION_DICTIONARY.get(key, string_to_context_key(key)): val for key, val in
                          host_list[0].items()}
        title = f'{INTEGRATION_NAME} - IP: {name} info.'
        context = {
            f'{INTEGRATION_CONTEXT_NAME}.IP(val.ReferenceID && val.ReferenceID === obj.ReferenceID)': fixed_keys_obj}
        human_readable = tableToMarkdown(title, fixed_keys_obj, headerTransform=pascalToSpace)
        return human_readable, context, raw_response

    def search_related_objects_by_ip_command(client: Client, args: Dict) -> Tuple[str, Dict, Dict]:
        """
        Args:
            client: Client object
            args: Usually demisto.args()

        Returns:
            Outputs
        """
        ip = args.get('ip')
        max_results = args.get('max_results')
        raw_response = client.search_related_objects_by_ip(ip, max_results)
        obj_list = raw_response.get('result')
        if not obj_list:
            return f'{INTEGRATION_NAME} - No objects associated with ip: {ip} were found', {}, {}
        fixed_keys_obj_list = []
        for obj in obj_list:
            fixed_keys_obj = {RESPONSE_TRANSLATION_DICTIONARY.get(key, string_to_context_key(key)): val for key, val in
                              obj.items()}
            fixed_keys_obj_list.append(fixed_keys_obj)

        title = f'{INTEGRATION_NAME} - IP: {ip} search results.'
        context = {
            f'{INTEGRATION_CONTEXT_NAME}.IPRelatedObjects(val.ReferenceID && val.ReferenceID === obj.ReferenceID)':
                fixed_keys_obj_list}
        human_readable = tableToMarkdown(title, fixed_keys_obj_list, headerTransform=pascalToSpace)
        return human_readable, context, raw_response


    def list_response_policy_zone_rules_command(client: Client, args: Dict) -> Tuple[str, Dict, Dict]:
        """
        Args:
            client: Client object
            args: Usually demisto.args()

        Returns:
            Outputs
        """
        zone = args.get('response_policy_zone_name')
        max_results = args.get('page_size', 50)
        next_page_id = args.get('next_page_id')
        if not zone and not next_page_id:
            raise DemistoException('To run this command either a zone or a next page ID must be given')
        raw_response = client.list_response_policy_zone_rules(zone, max_results, next_page_id)
        new_next_page_id = raw_response.get('next_page_id')

        rules_list = raw_response.get('result')
        if not rules_list:
            return f'{INTEGRATION_NAME} - No rules associated to zone: {zone} were found', {}, {}

        fixed_keys_rule_list = []
        for rule in rules_list:
            fixed_keys_rule = {RESPONSE_TRANSLATION_DICTIONARY.get(key, string_to_context_key(key)): val for key, val in
                               rule.items() if key != '_ref'}
            fixed_keys_rule_list.append(fixed_keys_rule)
        zone_name = zone.capitalize() if zone else fixed_keys_rule_list[0].get('Name')
        title = f'{INTEGRATION_NAME} - Zone: {zone_name} rule list.'
        context = {
            f'{INTEGRATION_CONTEXT_NAME}.ResponsePolicyZoneRulesList(val.Name && val.Name === obj.Name)':
                fixed_keys_rule_list
        }
        if new_next_page_id:
            context.update({
                f'{INTEGRATION_CONTEXT_NAME}.RulesNextPage(val.NextPageID !== obj.NextPageID)': {   # type: ignore
                    'NextPageID': new_next_page_id}
            })
        human_readable = tableToMarkdown(title, fixed_keys_rule_list,
                                         headerTransform=pascalToSpace)
        return human_readable, context, raw_response


    def list_response_policy_zones_command(client: Client, args: Dict) -> Tuple[str, Dict, Dict]:
        """
        Args:
            client: Client object
            args: Usually demisto.args()

        Returns:
            Outputs
        """
        max_results = args.get('max_results', 50)
        raw_response = client.list_response_policy_zones(max_results)
        zones_list = raw_response.get('result')
        if not zones_list:
            return f'{INTEGRATION_NAME} - No Response Policy Zones were found', {}, {}
        fixed_keys_zone_list = []
        for zone in zones_list:
            fixed_keys_zone = {RESPONSE_TRANSLATION_DICTIONARY.get(key, string_to_context_key(key)): val for key, val in
                               zone.items()}
            fixed_keys_zone_list.append(fixed_keys_zone)
        display_first_x_results = f'(first {max_results} results)' if max_results else ''
        title = f'{INTEGRATION_NAME} - Response Policy Zones list {display_first_x_results}:'
        context = {
            f'{INTEGRATION_CONTEXT_NAME}.ResponsePolicyZones(val.FQDN && val.FQDN === obj.FQDN)': fixed_keys_zone_list}
        human_readable = tableToMarkdown(title, fixed_keys_zone_list, headerTransform=pascalToSpace)
        return human_readable, context, raw_response


    def create_response_policy_zone_command(client: Client, args: Dict) -> Tuple[str, Dict, Dict]:
        """
        Args:
            client: Client object
            args: Usually demisto.args()

        Returns:
            Outputs
        """
        fqdn = args.get('FQDN')
        rpz_policy = args.get('rpz_policy')
        rpz_severity = args.get('rpz_severity')
        substitute_name = args.get('substitute_name')
        rpz_type = args.get('rpz_type')
        if rpz_policy == 'SUBSTITUTE' and not substitute_name:
            raise DemistoException(f'Response policy zone with policy SUBSTITUTE requires a substitute name')
        raw_response = client.create_response_policy_zone(fqdn, rpz_policy, rpz_severity, substitute_name, rpz_type)
        zone = raw_response.get('result', {})
        fixed_keys_rule_res = {RESPONSE_TRANSLATION_DICTIONARY.get(key, string_to_context_key(key)): val for key, val in
                               zone.items()}
        title = f'{INTEGRATION_NAME} - Response Policy Zone: {fqdn} has been created'
        context = {
            f'{INTEGRATION_CONTEXT_NAME}.ResponsePolicyZones(val.FQDN && val.FQDN === obj.FQDN)': fixed_keys_rule_res}
        human_readable = tableToMarkdown(title, fixed_keys_rule_res, headerTransform=pascalToSpace)
        return human_readable, context, raw_response


    def delete_response_policy_zone_command(client: Client, args: Dict) -> Tuple[str, Dict, Dict]:
        """
        Args:
            client: Client object
            args: Usually demisto.args()

        Returns:
            Outputs
        """
        ref_id = args.get('reference_id')
        raw_response = client.delete_response_policy_zone(ref_id)
        deleted_rule_ref_id = raw_response.get('result', {})
        human_readable = f'{INTEGRATION_NAME} - Response Policy Zone with the following id was deleted: \n ' \
                         f'{deleted_rule_ref_id}'
        return human_readable, {}, raw_response


    def create_rpz_rule_command(client: Client, args: Dict) -> Tuple[str, Dict, Dict]:
        """
        Args:
            client: Client object
            args: Usually demisto.args()

        Returns:
            Outputs
        """
        rule_type = args.get('rule_type')
        object_type = args.get('object_type')
        name = args.get('name')
        rp_zone = args.get('rp_zone')
        comment = args.get('comment')
        substitute_name = args.get('substitute_name')
        if rule_type == 'Substitute (domain name)' and not substitute_name:
            raise DemistoException(f'Substitute (domain name) rules requires a substitute name argument')
        raw_response = client.create_rpz_rule(rule_type, object_type, name, rp_zone, substitute_name, comment)
        rule = raw_response.get('result', {})
        fixed_keys_rule_res = {RESPONSE_TRANSLATION_DICTIONARY.get(key, string_to_context_key(key)): val for key, val in
                               rule.items()}
        title = f'{INTEGRATION_NAME} - Response Policy Zone rule: {name} has been created:'
        context = {
            f'{INTEGRATION_CONTEXT_NAME}.ModifiedResponsePolicyZoneRules(val.Name && val.Name === obj.Name)': fixed_keys_rule_res}
        human_readable = tableToMarkdown(title, fixed_keys_rule_res, headerTransform=pascalToSpace)
        return human_readable, context, raw_response


    def create_a_substitute_record_rule_command(client: Client, args: Dict) -> Tuple[str, Dict, Dict]:
        """
        Args:
            client: Client object
            args: Usually demisto.args()

        Returns:
            Outputs
        """
        name = args.get('name')
        rp_zone = args.get('rp_zone')
        comment = args.get('comment')
        ipv4addr = args.get('ipv4addr')
        infoblox_object_type = 'record:rpz:a'

        raw_response = client.create_substitute_record_rule(infoblox_object_type, name=name, rp_zone=rp_zone,
                                                            comment=comment, ipv4addr=ipv4addr)
        rule = raw_response.get('result', {})
        fixed_keys_rule_res = {RESPONSE_TRANSLATION_DICTIONARY.get(key, string_to_context_key(key)): val for key, val in
                               rule.items()}
        title = f'{INTEGRATION_NAME} - Response Policy Zone rule: {name} has been created:'
        context = {
            f'{INTEGRATION_CONTEXT_NAME}.ModifiedResponsePolicyZoneRules(val.Name && val.Name === obj.Name)': fixed_keys_rule_res}
        human_readable = tableToMarkdown(title, fixed_keys_rule_res, headerTransform=pascalToSpace)
        return human_readable, context, raw_response

    def create_a_record_command(client: Client, args: Dict) -> Tuple[str, Dict, Dict]:
        """
        Args:
            client: Client object
            args: Usually demisto.args()

        Returns:
            Outputs
        """
        name = args.get('name')
        comment = args.get('comment')
        ipv4addr = args.get('ipv4addr')
        infoblox_object_type = 'record:a'

        raw_response = client.create_record(infoblox_object_type, name=name,
                                            comment=comment, ipv4addr=ipv4addr)
        rule = raw_response.get('result', {})
        fixed_keys_rule_res = {RESPONSE_TRANSLATION_DICTIONARY.get(key, string_to_context_key(key)): val for key, val in
                               rule.items()}
        title = f'{INTEGRATION_NAME} - Host Record: {name} has been created:'
        context = {
            f'{INTEGRATION_CONTEXT_NAME}.ModifiedHostRecord(val.Name && val.Name === obj.Name)': fixed_keys_rule_res}
        human_readable = tableToMarkdown(title, fixed_keys_rule_res, headerTransform=pascalToSpace)
        return human_readable, context, raw_response

    def add_host_record_command(client: Client, args: Dict) -> Tuple[str, Dict, Dict]:
        """
        Args:
            client: Client object
            args: Usually demisto.args()

        Returns:
            Outputs
        """
        host = args.get('host')
        ipadd = args.get('ipadd')

        raw_response = client.add_host(host,ipadd)
        demisto.results(raw_response)

        return f'{INTEGRATION_NAME} - ' + raw_response['result'], {}, {}

    def update_host_record_command(client: Client, args: Dict) -> Tuple[str, Dict, Dict]:
        """
        Args:
            client: Client object
            args: Usually demisto.args()

        Returns:
            Outputs
        """

        host = args.get('host')
        refid = args.get('refid')
        ipadd = args.get('ipadd')

        if refid:
            payload = '{"ipv4addr":"' + str(ipadd) + '"}'
            headers = {'content-type': 'application/json', 'Accept-Charset': 'UTF-8'}

            raw_response = client.update_host(host,ipadd,refid)
            demisto.results(raw_response)

            return f'{INTEGRATION_NAME} - ' + raw_response['result'], {}, {}
        else:
            return f'{INTEGRATION_NAME} - No RefID', {}, {}

    def delete_host_record_command(client: Client, args: Dict) -> Tuple[str, Dict, Dict]:
        """
        Args:
            client: Client object
            args: Usually demisto.args()

        Returns:
            Outputs
        """

        refid = args.get('refid')

        if "/" in refid:
            refIDStr = str(refid).split("/")
            refIDStr = refIDStr[1].split(":")
            refid = refIDStr[0]


        if refid:
            headers = {'content-type': 'application/json', 'Accept-Charset': 'UTF-8'}

            raw_response = client.delete_host(refid)
            demisto.results(raw_response)

            return f'{INTEGRATION_NAME} - ' + raw_response['result'], {}, {}
        else:
            return f'{INTEGRATION_NAME} - No RefID', {}, {}

    def create_aaaa_substitute_record_rule_command(client: Client, args: Dict) -> Tuple[str, Dict, Dict]:
        """
        Args:
            client: Client object
            args: Usually demisto.args()

        Returns:
            Outputs
        """
        name = args.get('name')
        rp_zone = args.get('rp_zone')
        comment = args.get('comment')
        ipv6addr = args.get('ipv6addr')
        infoblox_object_type = 'record:rpz:aaaa'

        raw_response = client.create_substitute_record_rule(infoblox_object_type, name=name, rp_zone=rp_zone,
                                                            comment=comment, ipv6addr=ipv6addr)
        rule = raw_response.get('result', {})
        fixed_keys_rule_res = {RESPONSE_TRANSLATION_DICTIONARY.get(key, string_to_context_key(key)): val for key, val in
                               rule.items()}
        title = f'{INTEGRATION_NAME} - Response Policy Zone rule: {name} has been created:'
        context = {
            f'{INTEGRATION_CONTEXT_NAME}.ModifiedResponsePolicyZoneRules(val.Name && val.Name === obj.Name)': fixed_keys_rule_res}
        human_readable = tableToMarkdown(title, fixed_keys_rule_res, headerTransform=pascalToSpace)
        return human_readable, context, raw_response


    def create_mx_substitute_record_rule_command(client: Client, args: Dict) -> Tuple[str, Dict, Dict]:
        """
        Args:
            client: Client object
            args: Usually demisto.args()

        Returns:
            Outputs
        """
        name = args.get('name')
        rp_zone = args.get('rp_zone')
        comment = args.get('comment')
        mail_exchanger = args.get('mail_exchanger')
        preference = int(args.get('preference', 0))
        infoblox_object_type = 'record:rpz:mx'

        raw_response = client.create_substitute_record_rule(infoblox_object_type, name=name, rp_zone=rp_zone,
                                                            comment=comment, mail_exchanger=mail_exchanger,
                                                            preference=preference)
        rule = raw_response.get('result', {})
        fixed_keys_rule_res = {RESPONSE_TRANSLATION_DICTIONARY.get(key, string_to_context_key(key)): val for key, val in
                               rule.items()}
        title = f'{INTEGRATION_NAME} - Response Policy Zone rule: {name} has been created:'
        context = {
            f'{INTEGRATION_CONTEXT_NAME}.ModifiedResponsePolicyZoneRules(val.Name && val.Name === obj.Name)': fixed_keys_rule_res}
        human_readable = tableToMarkdown(title, fixed_keys_rule_res, headerTransform=pascalToSpace)
        return human_readable, context, raw_response


    def create_naptr_substitute_record_rule_command(client: Client, args: Dict) -> Tuple[str, Dict, Dict]:
        """
        Args:
            client: Client object
            args: Usually demisto.args()

        Returns:
            Outputs
        """
        name = args.get('name')
        rp_zone = args.get('rp_zone')
        comment = args.get('comment')
        order = int(args.get('order', 0))
        preference = int(args.get('preference', 0))
        replacement = args.get('replacement')
        infoblox_object_type = 'record:rpz:naptr'

        raw_response = client.create_substitute_record_rule(infoblox_object_type, name=name, rp_zone=rp_zone,
                                                            comment=comment, order=order, preference=preference,
                                                            replacement=replacement)

        rule = raw_response.get('result', {})
        fixed_keys_rule_res = {RESPONSE_TRANSLATION_DICTIONARY.get(key, string_to_context_key(key)): val for key, val in
                               rule.items()}
        title = f'{INTEGRATION_NAME} - Response Policy Zone rule: {name} has been created:'
        context = {
            f'{INTEGRATION_CONTEXT_NAME}.ModifiedResponsePolicyZoneRules(val.Name && val.Name === obj.Name)': fixed_keys_rule_res}
        human_readable = tableToMarkdown(title, fixed_keys_rule_res, headerTransform=pascalToSpace)
        return human_readable, context, raw_response


    def create_ptr_substitute_record_rule_command(client: Client, args: Dict) -> Tuple[str, Dict, Dict]:
        """
        Args:
            client: Client object
            args: Usually demisto.args()

        Returns:
            Outputs
        """
        rp_zone = args.get('rp_zone')
        comment = args.get('comment')
        ptrdname = args.get('ptrdname')
        name = args.get('name')
        ipv4addr = args.get('ipv4addr')
        ipv6addr = args.get('ipv6addr')
        infoblox_object_type = 'record:rpz:ptr'
        if all([not name, not ipv4addr, not ipv6addr]):
            raise DemistoException('To run this command either \'name\', \'ipv4addr\' or \'ipv6addr\' should be given.')
        raw_response = client.create_substitute_record_rule(infoblox_object_type, name=name, rp_zone=rp_zone,
                                                            comment=comment, ptrdname=ptrdname, ipv4addr=ipv4addr,
                                                            ipv6addr=ipv6addr)
        rule = raw_response.get('result', {})
        fixed_keys_rule_res = {RESPONSE_TRANSLATION_DICTIONARY.get(key, string_to_context_key(key)): val for key, val in
                               rule.items()}
        title = f'{INTEGRATION_NAME} - Response Policy Zone rule: {name} has been created:'
        context = {
            f'{INTEGRATION_CONTEXT_NAME}.ModifiedResponsePolicyZoneRules(val.Name && val.Name === obj.Name)': fixed_keys_rule_res}
        human_readable = tableToMarkdown(title, fixed_keys_rule_res, headerTransform=pascalToSpace)
        return human_readable, context, raw_response


    def create_srv_substitute_record_rule_command(client: Client, args: Dict) -> Tuple[str, Dict, Dict]:
        """
        Args:
            client: Client object
            args: Usually demisto.args()

        Returns:
            Outputs
        """
        name = args.get('name')
        rp_zone = args.get('rp_zone')
        comment = args.get('comment')
        port = int(args.get('port', 0))
        priority = int(args.get('priority', 0))
        target = args.get('target')
        weight = int(args.get('weight', 0))
        infoblox_object_type = 'record:rpz:srv'

        raw_response = client.create_substitute_record_rule(infoblox_object_type, name=name, rp_zone=rp_zone,
                                                            comment=comment, port=port, priority=priority, target=target,
                                                            weight=weight)
        rule = raw_response.get('result', {})
        fixed_keys_rule_res = {RESPONSE_TRANSLATION_DICTIONARY.get(key, string_to_context_key(key)): val for key, val in
                               rule.items()}
        title = f'{INTEGRATION_NAME} - Response Policy Zone rule: {name} has been created:'
        context = {
            f'{INTEGRATION_CONTEXT_NAME}.ModifiedResponsePolicyZoneRules(val.Name && val.Name === obj.Name)': fixed_keys_rule_res}
        human_readable = tableToMarkdown(title, fixed_keys_rule_res, headerTransform=pascalToSpace)
        return human_readable, context, raw_response


    def create_txt_substitute_record_rule_command(client: Client, args: Dict) -> Tuple[str, Dict, Dict]:
        """
        Args:
            client: Client object
            args: Usually demisto.args()

        Returns:
            Outputs
        """
        name = args.get('name')
        rp_zone = args.get('rp_zone')
        comment = args.get('comment')
        text = args.get('text')
        infoblox_object_type = 'record:rpz:txt'

        raw_response = client.create_substitute_record_rule(infoblox_object_type, name=name, rp_zone=rp_zone,
                                                            comment=comment, text=text)
        rule = raw_response.get('result', {})
        fixed_keys_rule_res = {RESPONSE_TRANSLATION_DICTIONARY.get(key, string_to_context_key(key)): val for key, val in
                               rule.items()}
        title = f'{INTEGRATION_NAME} - Response Policy Zone rule: {name} has been created:'
        context = {
            f'{INTEGRATION_CONTEXT_NAME}.ModifiedResponsePolicyZoneRules(val.Name && val.Name === obj.Name)': fixed_keys_rule_res}
        human_readable = tableToMarkdown(title, fixed_keys_rule_res, headerTransform=pascalToSpace)
        return human_readable, context, raw_response


    def create_ipv4_substitute_record_rule_command(client: Client, args: Dict) -> Tuple[str, Dict, Dict]:
        """
        Args:
            client: Client object
            args: Usually demisto.args()

        Returns:
            Outputs
        """
        name = args.get('name')
        rp_zone = args.get('rp_zone')
        comment = args.get('comment')
        ipv4addr = args.get('ipv4addr')
        infoblox_object_type = 'record:rpz:a:ipaddress'

        raw_response = client.create_substitute_record_rule(infoblox_object_type, name=name, rp_zone=rp_zone,
                                                            comment=comment, ipv4addr=ipv4addr)
        rule = raw_response.get('result', {})
        fixed_keys_rule_res = {RESPONSE_TRANSLATION_DICTIONARY.get(key, string_to_context_key(key)): val for key, val in
                               rule.items()}
        title = f'{INTEGRATION_NAME} - Response Policy Zone rule: {name} has been created:'
        context = {
            f'{INTEGRATION_CONTEXT_NAME}.ModifiedResponsePolicyZoneRules(val.Name && val.Name === obj.Name)': fixed_keys_rule_res}
        human_readable = tableToMarkdown(title, fixed_keys_rule_res, headerTransform=pascalToSpace)
        return human_readable, context, raw_response


    def create_ipv6_substitute_record_rule_command(client: Client, args: Dict) -> Tuple[str, Dict, Dict]:
        """
        Args:
            client: Client object
            args: Usually demisto.args()

        Returns:
            Outputs
        """
        name = args.get('name')
        rp_zone = args.get('rp_zone')
        comment = args.get('comment')
        ipv6addr = args.get('ipv6addr')
        infoblox_object_type = 'record:rpz:aaaa:ipaddress'

        raw_response = client.create_substitute_record_rule(infoblox_object_type, name=name, rp_zone=rp_zone,
                                                            comment=comment, ipv6addr=ipv6addr)
        rule = raw_response.get('result', {})
        fixed_keys_rule_res = {RESPONSE_TRANSLATION_DICTIONARY.get(key, string_to_context_key(key)): val for key, val in
                               rule.items()}
        title = f'{INTEGRATION_NAME} - Response Policy Zone rule: {name} has been created:'
        context = {
            f'{INTEGRATION_CONTEXT_NAME}.ModifiedResponsePolicyZoneRules(val.Name && val.Name === obj.Name)': fixed_keys_rule_res}
        human_readable = tableToMarkdown(title, fixed_keys_rule_res, headerTransform=pascalToSpace)
        return human_readable, context, raw_response


    def enable_rule_command(client: Client, args: Dict) -> Tuple[str, Dict, Dict]:
        """
        Args:
            client: Client object
            args: Usually demisto.args()

        Returns:
            Outputs
        """
        reference_id = args.get('reference_id')
        raw_response = client.change_rule_status(reference_id, disable=False)

        rule = raw_response.get('result', {})
        fixed_keys_rule_res = {RESPONSE_TRANSLATION_DICTIONARY.get(key, string_to_context_key(key)): val for key, val in
                               rule.items()}
        title = f'{INTEGRATION_NAME} - Response Policy Zone rule: {fixed_keys_rule_res.get("Name")} has been enabled'
        context = {
            f'{INTEGRATION_CONTEXT_NAME}.ModifiedResponsePolicyZoneRules(val.Name && val.Name === obj.Name)': fixed_keys_rule_res}
        human_readable = tableToMarkdown(title, fixed_keys_rule_res, headerTransform=pascalToSpace)
        return human_readable, context, raw_response


    def disable_rule_command(client: Client, args: Dict) -> Tuple[str, Dict, Dict]:
        """
        Args:
            client: Client object
            args: Usually demisto.args()

        Returns:
            Outputs
        """
        reference_id = args.get('reference_id')
        raw_response = client.change_rule_status(reference_id, disable=True)

        rule = raw_response.get('result', {})
        fixed_keys_rule_res = {RESPONSE_TRANSLATION_DICTIONARY.get(key, string_to_context_key(key)): val for key, val in
                               rule.items()}
        title = f'{INTEGRATION_NAME} - Response Policy Zone rule: {fixed_keys_rule_res.get("Name")} has been disabled'
        context = {
            f'{INTEGRATION_CONTEXT_NAME}.ModifiedResponsePolicyZoneRules(val.Name && val.Name === obj.Name)': fixed_keys_rule_res}
        human_readable = tableToMarkdown(title, fixed_keys_rule_res, headerTransform=pascalToSpace)
        return human_readable, context, raw_response


    def get_object_fields_command(client: Client, args: Dict) -> Tuple[str, Dict, Dict]:
        """
        Args:
            client: Client object
            args: Usually demisto.args()

        Returns:
            Outputs
        """
        object_type = args.get('object_type')
        raw_response = client.get_object_fields(object_type)

        fields = raw_response.get('result', {}).get('fields', {})
        name_list = [field_obj.get('name') for field_obj in fields]
        title = f'{INTEGRATION_NAME} - Object {object_type} supported fields: '
        context_entry = {
            'ObjectType': object_type,
            'SupportedFields': name_list
        }
        context = {
            f'{INTEGRATION_CONTEXT_NAME}.ObjectFields(val.ObjectType && val.ObjectType === obj.ObjectType)': context_entry
        }
        human_readable = tableToMarkdown(title, name_list, headers=['Field Names'], headerTransform=pascalToSpace)
        return human_readable, context, raw_response


    def get_refid_command(client: Client, args: Dict) -> Tuple[str, Dict, Dict]:
        """
        Args:
            client: Client object
            args: Demisto.args()

        Returns:
            Outputs: Infoblox Ref ID for host record
        """
        refid = ""

        view = args.get('view')
        host = args.get('host')
        ipadd = args.get('ipadd')
        domain = args.get('domain')
        status = args.get('status')
        deletes = args.get('deletes')
        host = host.lower() + "." + domain.lower()
        demisto.results("Getting Ref ID for " + host)
        raw_response = client.get_refid(view,host,status)

        if deletes == "yes":
            if len(raw_response['result'])<=0:
                demisto.results("No Results")
                return {},{},{}
            else:
                retRefId = raw_response["result"][0]["_ref"]
                if ( retRefId ):
                    ref_array = retRefId.split("/")
                    refid = ref_array[1]


                    hosts = [
                        {
                            'name': host,
                            'ipadd': ipadd,
                            'refid': refid
                        }
                    ]

                    markdown = '### Global Protect\n'
                    markdown += tableToMarkdown('Hosts Offline', hosts, headers=['id', 'name'])

                    results = CommandResults(
                        readable_output=markdown,
                        outputs_prefix='GlobalProtect.Hosts.Deletes',
                        outputs_key_field='name',
                        outputs=hosts
                    )
                    return_results(results)
                    return {},{},{}
                else:
                    return {},{},{}


        else:
            # If the response is blank then Add Host GlobalProtect.Hosts.Adds key Else Add Hosts GlobalProtect.Hosts.Updates
            if len(raw_response['result'])<=0:
                hosts = [
                    {
                        'name': host,
                        'ipadd': ipadd,
                        'refid': ""
                    }
                ]

                markdown = '### Global Protect\n'
                markdown += tableToMarkdown('Hosts Online', hosts, headers=['id', 'name'])

                results = CommandResults(
                    readable_output=markdown,
                    outputs_prefix='GlobalProtect.Hosts.Adds',
                    outputs_key_field='name',
                    outputs=hosts
                )
                return_results(results)
                return {},{},{}

            else:
                retRefId = raw_response["result"][0]["ipv4addrs"][0]["_ref"]
                infobloxHost = raw_response["result"][0]["ipv4addrs"][0]["host"]
                infobloxIP = raw_response["result"][0]["ipv4addrs"][0]["ipv4addr"]

                if ( retRefId and ((host != infobloxHost) or (ipadd != infobloxIP)) ):
                    ref_array = retRefId.split("/")
                    refid = ref_array[1]

                    hosts = [
                        {
                            'name': host,
                            'ipadd': ipadd,
                            'refid': retRefId
                        }
                    ]

                    markdown = '### Global Protect\n'
                    markdown += tableToMarkdown('Hosts Online', hosts, headers=['id', 'name'])

                    results = CommandResults(
                        readable_output=markdown,
                        outputs_prefix='GlobalProtect.Hosts.Updates',
                        outputs_key_field='name',
                        outputs=hosts
                    )
                    return_results(results)

            ### Build Context and pretty output
            host_list = raw_response.get('result')

            # If no IP object was returned
            if not host_list:
                return f'{INTEGRATION_NAME} - Could not find any data corresponds to: {host}', {}, {}
            fixed_keys_obj = {RESPONSE_TRANSLATION_DICTIONARY.get(key, string_to_context_key(key)): val for key, val in
                              host_list[0].items()}
            title = f'{INTEGRATION_NAME} - Host: {host} info.'
            context = {
                f'{INTEGRATION_CONTEXT_NAME}.IP(val.ReferenceID && val.ReferenceID === obj.ReferenceID)': fixed_keys_obj}
            human_readable = tableToMarkdown(title, fixed_keys_obj, headerTransform=pascalToSpace)
            return human_readable, context, raw_response

    def search_rule_command(client: Client, args: Dict) -> Tuple[str, Dict, Dict]:
        """
        Args:
            client: Client object
            args: Usually demisto.args()

        Returns:
            Outputs
        """
        object_type = args.get('object_type')
        rule_name = args.get('rule_name')
        output_fields = args.get('output_fields')
        raw_response = client.search_rule(object_type, rule_name, output_fields)
        rule_list = raw_response.get('result')
        if not rule_list:
            return f'No rules with name: {rule_name} of type: {object_type} were found', {}, raw_response
        fixed_keys_rule_list = []
        for rule in rule_list:
            fixed_keys_rule = {RESPONSE_TRANSLATION_DICTIONARY.get(key, string_to_context_key(key)): val for key, val in
                               rule.items()}
            fixed_keys_rule_list.append(fixed_keys_rule)
        title = f'{INTEGRATION_NAME} - Search result for: {rule_name}: '
        context = {
            f'{INTEGRATION_CONTEXT_NAME}.RulesSearchResults(val.Name && val.Name === obj.Name)': fixed_keys_rule_list
        }
        human_readable = tableToMarkdown(title, fixed_keys_rule_list, headerTransform=pascalToSpace)
        return human_readable, context, raw_response


    def delete_rpz_rule_command(client: Client, args: Dict) -> Tuple[str, Dict, Dict]:
        """
        Args:
            client: Client object
            args: Usually demisto.args()

        Returns:
            Outputs
        """
        reference_id = args.get('reference_id')
        raw_response = client.delete_rpz_rule(reference_id)
        rule_reference_id = raw_response.get('result')
        title = f'{INTEGRATION_NAME} - A rule with the following id was deleted: \n {rule_reference_id}'
        return title, {}, raw_response


    ''' COMMANDS MANAGER / SWITCH PANEL '''


    def main():  # pragma: no cover
        params = demisto.params()
        base_url = f"{params.get('url', '').rstrip('/')}/wapi/v2.10.5/"
        verify = not params.get('insecure', False)
        proxy = params.get('proxy') == 'true'
        user = demisto.get(params, 'credentials.identifier')
        password = demisto.get(params, 'credentials.password')
        default_request_params = {
            '_return_as_object': '1'
        }
        client = Client(base_url, verify=verify, proxy=proxy, auth=(user, password), params=default_request_params)
        command = demisto.command()
        demisto.info(f'Command being called is {command}')

        # Switch case
        commands: Dict[str, Callable[[Client, Dict[str, str]], Tuple[str, Dict[Any, Any], Dict[Any, Any]]]] = {
            'test-module': test_module_command,
            f'{INTEGRATION_COMMAND_NAME}-get-ip': get_ip_command,
            f'{INTEGRATION_COMMAND_NAME}-get-name': get_name_command,
            f'{INTEGRATION_COMMAND_NAME}-search-related-objects-by-ip': search_related_objects_by_ip_command,
            f'{INTEGRATION_COMMAND_NAME}-list-response-policy-zones': list_response_policy_zones_command,
            f'{INTEGRATION_COMMAND_NAME}-list-response-policy-zone-rules': list_response_policy_zone_rules_command,
            f'{INTEGRATION_COMMAND_NAME}-create-response-policy-zone': create_response_policy_zone_command,
            f'{INTEGRATION_COMMAND_NAME}-delete-response-policy-zone': delete_response_policy_zone_command,
            f'{INTEGRATION_COMMAND_NAME}-create-rpz-rule': create_rpz_rule_command,
            f'{INTEGRATION_COMMAND_NAME}-create-a-record': create_a_record_command,
            f'{INTEGRATION_COMMAND_NAME}-update-host-record': update_host_record_command,
            f'{INTEGRATION_COMMAND_NAME}-delete-host-record': delete_host_record_command,
            f'{INTEGRATION_COMMAND_NAME}-add-host-record': add_host_record_command,
            f'{INTEGRATION_COMMAND_NAME}-get-refid': get_refid_command,
            f'{INTEGRATION_COMMAND_NAME}-create-a-substitute-record-rule': create_a_substitute_record_rule_command,
            f'{INTEGRATION_COMMAND_NAME}-create-aaaa-substitute-record-rule': create_aaaa_substitute_record_rule_command,
            f'{INTEGRATION_COMMAND_NAME}-create-mx-substitute-record-rule': create_mx_substitute_record_rule_command,
            f'{INTEGRATION_COMMAND_NAME}-create-naptr-substitute-record-rule': create_naptr_substitute_record_rule_command,
            f'{INTEGRATION_COMMAND_NAME}-create-ptr-substitute-record-rule': create_ptr_substitute_record_rule_command,
            f'{INTEGRATION_COMMAND_NAME}-create-srv-substitute-record-rule': create_srv_substitute_record_rule_command,
            f'{INTEGRATION_COMMAND_NAME}-create-txt-substitute-record-rule': create_txt_substitute_record_rule_command,
            f'{INTEGRATION_COMMAND_NAME}-create-ipv4-substitute-record-rule': create_ipv4_substitute_record_rule_command,
            f'{INTEGRATION_COMMAND_NAME}-create-ipv6-substitute-record-rule': create_ipv6_substitute_record_rule_command,
            f'{INTEGRATION_COMMAND_NAME}-enable-rule': enable_rule_command,
            f'{INTEGRATION_COMMAND_NAME}-disable-rule': disable_rule_command,
            f'{INTEGRATION_COMMAND_NAME}-get-object-fields': get_object_fields_command,
            f'{INTEGRATION_COMMAND_NAME}-search-rule': search_rule_command,
            f'{INTEGRATION_COMMAND_NAME}-delete-rpz-rule': delete_rpz_rule_command,
        }
        try:
            if command in commands:
                return_outputs(*commands[command](client, demisto.args()))
        # Log exceptions
        except Exception as e:
            err_msg = f'Error in {INTEGRATION_NAME} - {e}'
            return_error(err_msg, error=e)


    if __name__ in ["__builtin__", "builtins", '__main__']:  # pragma: no cover
        main()
  type: python
  commands:
  - name: infoblox-get-ip
    arguments:
    - name: ip
      required: true
      description: The IP address for which to retrieve information.
    outputs:
    - contextPath: Infoblox.IP.ReferenceID
      description: Reference ID of the object.
      type: number
    - contextPath: Infoblox.IP.MacAddress
      description: The Mac address of the IP.
      type: string
    - contextPath: Infoblox.IP.Network
      description: The network that the IP belongs, in FQDN/CIDR format.
      type: string
    - contextPath: Infoblox.IP.NetworkView
      description: The name of the network view.
      type: string
    - contextPath: Infoblox.IP.Status
      description: The current status of the address.
      type: string
    - contextPath: Infoblox.IP.IsConflict
      description: Whether the IP address has either a MAC address conflict or a DHCP
        lease conflict detected through a network discovery (if set to true).
      type: string
    - contextPath: Infoblox.IP. Objects
      description: The objects associated with the IP address.
      type: string
    - contextPath: Infoblox.IP.Types
      description: The current status of the address.
      type: string
    - contextPath: Infoblox.IP. Names
      description: The DNS names. For example, if the IP address belongs to a host
        record, this field contains the hostname.
      type: string
    - contextPath: Infoblox.IP. Extattrs
      description: Extra attributes relevant for this object.
      type: string
    - contextPath: Infoblox.IP.IpAddress
      description: The IP address.
      type: string
    - contextPath: Infoblox.IP.Usage
      description: Indicates whether the IP address is configured for DNS or DHCP.
      type: string
    description: Get IP info
  - name: infoblox-search-related-objects-by-ip
    arguments:
    - name: ip
      required: true
      description: The IP address for which to search.
    - name: max_results
      description: The maximum results to return.
    outputs:
    - contextPath: Infoblox.IPRelatedObjects.ReferenceID
      description: The reference ID of the related object.
      type: Unknown
    description: Searches IP related objects by a given IP.
  - name: infoblox-list-response-policy-zone-rules
    arguments:
    - name: response_policy_zone_name
      description: The response policy zone name to list the rules (FQDN).
    - name: page_size
      description: The number of results in each page.
      defaultValue: "50"
    - name: next_page_id
      description: The next page ID that was returned when last running this command.
    outputs:
    - contextPath: Infoblox.ResponsePolicyZoneRulesList.Name
      description: Rule name.
      type: string
    - contextPath: Infoblox.ResponsePolicyZoneRulesList.Disable
      description: Whether the rule is disabled.
      type: boolean
    - contextPath: Infoblox.ResponsePolicyZoneRulesList.Comment
      description: The comment for this rule.
      type: string
    - contextPath: Infoblox.ResponsePolicyZoneRulesList.Type
      description: The object type as used in Infoblox.
      type: string
    - contextPath: Infoblox.ResponsePolicyZoneRulesList.View
      description: View of the definition.
      type: string
    - contextPath: Infoblox.ResponsePolicyZoneRulesList.Zone
      description: The zone to which this rule belongs.
      type: string
    - contextPath: Infoblox.RulesNextPage.NextPageID
      description: Retrieves the next page of the search. The last NextpageID corresponds
        to the last search performed.
      type: string
    description: Lists all response policy rules that belong to the given response
      policy zone.
  - name: infoblox-list-response-policy-zones
    arguments:
    - name: max_results
      description: Maximum results to return. (default is 50)
    outputs:
    - contextPath: Infoblox.ResponsePolicyZones.Disable
      description: Whether this zone is disabled.
      type: boolean
    - contextPath: Infoblox.ResponsePolicyZones.FQDN
      description: The fully qualified domain name.
      type: string
    - contextPath: Infoblox.ResponsePolicyZones.ReferenceID
      description: The reference ID of the object.
      type: string
    - contextPath: Infoblox.ResponsePolicyZones.RpzPolicy
      description: The response policy zone override policy.
      type: string
    - contextPath: Infoblox.ResponsePolicyZones.RpzSeverity
      description: The severity of this response policy zone.
      type: string
    - contextPath: Infoblox.ResponsePolicyZones.RpzType
      description: The type of response policy zone.
      type: string
    - contextPath: Infoblox.ResponsePolicyZones.View
      description: The view of the definition.
      type: string
    description: List all response policy zones.
  - name: infoblox-create-response-policy-zone
    arguments:
    - name: FQDN
      required: true
      description: The name of this DNS zone in FQDN format.
    - name: rpz_policy
      required: true
      auto: PREDEFINED
      predefined:
      - DISABLED
      - GIVEN
      - NODATA
      - NXDOMAIN
      - PASSTHRU
      - SUBSTITUTE
      description: 'The override policy of the response policy zone. Can be: "DISABLED",
        "GIVEN", "NODATA", "NXDOMAIN", "PASSTHRU", or "SUBSTITUTE".'
    - name: rpz_severity
      required: true
      auto: PREDEFINED
      predefined:
      - CRITICAL
      - MAJOR
      - WARNING
      - INFORMATIONAL
      description: 'The severity of the response policy zone. Can be: "CRITICAL",
        "MAJOR", "WARNING", or "INFORMATIONAL".'
      defaultValue: MAJOR
    - name: substitute_name
      description: The alternative name of the redirect target in a substitute response
        policy. policy zone.
    - name: rpz_type
      auto: PREDEFINED
      predefined:
      - FEED
      - FIREEYE
      - LOCAL
      description: 'The type of the rpz zone. Can be: "FEED", "FIREEYE", or "LOCAL".'
      defaultValue: LOCAL
    outputs:
    - contextPath: Infoblox.ResponsePolicyZones.Disable
      description: Whether this zone is disabled.
      type: boolean
    - contextPath: Infoblox.ResponsePolicyZones.FQDN
      description: A fully qualified domain name.
      type: string
    - contextPath: Infoblox.ResponsePolicyZones.ReferenceID
      description: The reference ID of the object.
      type: string
    - contextPath: Infoblox.ResponsePolicyZones.RpzPolicy
      description: The response policy zone override policy.
      type: string
    - contextPath: Infoblox.ResponsePolicyZones.RpzSeverity
      description: The severity of the response policy zone.
      type: string
    - contextPath: Infoblox.ResponsePolicyZones.RpzType
      description: The type of rpz zone.
      type: string
    - contextPath: Infoblox.ResponsePolicyZones.View
      description: The view of the definition.
      type: string
    description: Creates a response policy zone.
  - name: infoblox-create-rpz-rule
    arguments:
    - name: rule_type
      required: true
      auto: PREDEFINED
      predefined:
      - Passthru
      - Block (No such domain)
      - Block (No data)
      - Substitute (domain name)
      description: 'The type of the rule to create. Can be: "Passthru", "Block" (No
        such domain), "Block" (No data), or "Substitute" (domain name).'
    - name: object_type
      required: true
      auto: PREDEFINED
      predefined:
      - Domain Name
      - IP address
      - Client IP address
      description: 'The type of the object for which to assign the rule. Can be: "Domain
        Name", "IP address", or "Client IP address".'
    - name: name
      required: true
      description: The rule name in a FQDN format.
    - name: rp_zone
      required: true
      description: The zone to assign the rule.
    - name: comment
      description: Adds a comment for this rule.
    - name: substitute_name
      description: The substitute name to assign (substitute domain only).
    outputs:
    - contextPath: Infoblox.ModifiedResponsePolicyZoneRules.Name
      description: The rule name.
      type: string
    - contextPath: Infoblox.ModifiedResponsePolicyZoneRules.Disable
      description: Whether this rule is disabled.
      type: boolean
    - contextPath: Infoblox.ModifiedResponsePolicyZoneRules.Comment
      description: The comment for this rule.
      type: string
    - contextPath: Infoblox.ModifiedResponsePolicyZoneRules.Type
      description: The object type as used in Infoblox.
      type: string
    - contextPath: Infoblox.ModifiedResponsePolicyZoneRules.View
      description: The view of the definition.
      type: string
    - contextPath: Infoblox.ModifiedResponsePolicyZoneRules.Zone
      description: The zone to which this rule belongs.
      type: string
    - contextPath: Infoblox.ModifiedResponsePolicyZoneRules.ReferenceID
      description: The reference ID of the rule.
      type: string
    description: Creates a response policy rule.
  - name: infoblox-create-a-substitute-record-rule
    arguments:
    - name: name
      required: true
      description: The name for a record in FQDN format.
    - name: rp_zone
      required: true
      description: The zone to assign the rule.
    - name: comment
      description: Add a comment for this rule.
    - name: ipv4addr
      description: The IPv4 address of the substitute rule.
    outputs:
    - contextPath: Infoblox.ModifiedResponsePolicyZoneRules.Name
      description: The name of the rule.
      type: string
    - contextPath: Infoblox.ModifiedResponsePolicyZoneRules.Disable
      description: Whether this rule is disabled.
      type: boolean
    - contextPath: Infoblox.ModifiedResponsePolicyZoneRules.Comment
      description: The comment for this rule.
      type: string
    - contextPath: Infoblox.ModifiedResponsePolicyZoneRules.Type
      description: The object type as used in Infoblox.
      type: string
    - contextPath: Infoblox.ModifiedResponsePolicyZoneRules.View
      description: The view of the definition.
      type: string
    - contextPath: Infoblox.ModifiedResponsePolicyZoneRules.Zone
      description: The zone to which this rule belongs.
      type: string
    - contextPath: Infoblox.ModifiedResponsePolicyZoneRules.ReferenceID
      description: The reference ID of the rule.
      type: string
    description: Creates a substitute record rule.
  - name: infoblox-create-aaaa-substitute-record-rule
    arguments:
    - name: name
      required: true
      description: The name for a record in FQDN format.
    - name: rp_zone
      required: true
      description: The zone to assign the rule.
    - name: comment
      description: Add a comment for this rule.
    - name: ipv6addr
      description: The IPv6 address of the substitute rule.
    outputs:
    - contextPath: Infoblox.ModifiedResponsePolicyZoneRules.Name
      description: The name of the rule.
      type: string
    - contextPath: Infoblox.ModifiedResponsePolicyZoneRules.Disable
      description: Whether this rule is disabled.
      type: boolean
    - contextPath: Infoblox.ModifiedResponsePolicyZoneRules.Comment
      description: The comment for this rule.
      type: string
    - contextPath: Infoblox.ModifiedResponsePolicyZoneRules.Type
      description: The object type as used in Infoblox.
      type: string
    - contextPath: Infoblox.ModifiedResponsePolicyZoneRules.View
      description: The view of the definition.
      type: string
    - contextPath: Infoblox.ModifiedResponsePolicyZoneRules.Zone
      description: The zone to which this rule belongs.
      type: string
    - contextPath: Infoblox.ModifiedResponsePolicyZoneRules.ReferenceID
      description: The reference ID of the rule.
      type: string
    description: Creates a substitute rule for an AAAA record.
  - name: infoblox-create-mx-substitute-record-rule
    arguments:
    - name: name
      required: true
      description: The name for a record in FQDN format.
    - name: rp_zone
      required: true
      description: The zone to assign the rule.
    - name: comment
      description: Add a comment for this rule.
    - name: mail_exchanger
      required: true
      description: The mail exchanger name in FQDN format. This value can be in unicode
        format.
    - name: preference
      required: true
      description: Preference value, 0 to 65535 (inclusive).
    outputs:
    - contextPath: Infoblox.ModifiedResponsePolicyZoneRules.Name
      description: The name of the rule.
      type: string
    - contextPath: Infoblox.ModifiedResponsePolicyZoneRules.Disable
      description: Whether this rule is disabled.
      type: boolean
    - contextPath: Infoblox.ModifiedResponsePolicyZoneRules.Comment
      description: The comment for this rule.
      type: string
    - contextPath: Infoblox.ModifiedResponsePolicyZoneRules.Type
      description: The object type as used in Infoblox.
      type: string
    - contextPath: Infoblox.ModifiedResponsePolicyZoneRules.View
      description: The view of the definition.
      type: string
    - contextPath: Infoblox.ModifiedResponsePolicyZoneRules.Zone
      description: The zone to which this rule belongs.
      type: string
    - contextPath: Infoblox.ModifiedResponsePolicyZoneRules.ReferenceID
      description: The reference ID of the rule.
      type: string
    description: Creates a substitute rule for the MX record.
  - name: infoblox-create-naptr-substitute-record-rule
    arguments:
    - name: name
      required: true
      description: The name for a record in FQDN forma.
    - name: rp_zone
      required: true
      description: The zone to assign the rule.
    - name: comment
      description: Add a comment for this rule.
    - name: order
      required: true
      description: The order parameter of the substitute rule of the NAPTR record.
        This parameter specifies the order in which the NAPTR rules are applied when
        multiple rules are present. Can be from 0 to 65535 (inclusive).
    - name: preference
      required: true
      description: Preference value, 0 to 65535 (inclusive).
    - name: replacement
      required: true
      description: The substitute rule object replacement field of the NAPTR record.
        For non-terminal NAPTR records, this field specifies the next domain name
        to look up.
    outputs:
    - contextPath: Infoblox.ModifiedResponsePolicyZoneRules.Name
      description: The name of the rule.
      type: string
    - contextPath: Infoblox.ModifiedResponsePolicyZoneRules.Disable
      description: Whether this rule is disabled.
      type: boolean
    - contextPath: Infoblox.ModifiedResponsePolicyZoneRules.Comment
      description: The comment for this rule.
      type: string
    - contextPath: Infoblox.ModifiedResponsePolicyZoneRules.Type
      description: The object type as used in Infoblox.
      type: string
    - contextPath: Infoblox.ModifiedResponsePolicyZoneRules.View
      description: The view of the definition.
      type: string
    - contextPath: Infoblox.ModifiedResponsePolicyZoneRules.Zone
      description: The zone to which this rule belongs.
      type: string
    - contextPath: Infoblox.ModifiedResponsePolicyZoneRules.ReferenceID
      description: The reference ID of the rule.
      type: string
    description: Creates a substitute rule for a NAPTR record.
  - name: infoblox-create-ptr-substitute-record-rule
    arguments:
    - name: rp_zone
      required: true
      description: The zone to assign the rule.
    - name: comment
      description: Add a comment for this rule.
    - name: ptrdname
      required: true
      description: The domain name of the RPZ substitute rule object of the PTR record
        in FQDN format.
    - name: name
      description: The name of the RPZ Substitute rule object of the PTR record in
        FQDN format.
    - name: ipv4addr
      description: The IPv4 Address of the substitute rule.
    - name: ipv6addr
      description: The IPv6 Address of the substitute rule.
    outputs:
    - contextPath: Infoblox.ModifiedResponsePolicyZoneRules.Name
      description: The name of the rule.
      type: string
    - contextPath: Infoblox.ModifiedResponsePolicyZoneRules.Disable
      description: Whether this rule is disabled.
      type: boolean
    - contextPath: Infoblox.ModifiedResponsePolicyZoneRules.Comment
      description: The Comment for this rule.
      type: string
    - contextPath: Infoblox.ModifiedResponsePolicyZoneRules.Type
      description: The object type as used in Infoblox.
      type: string
    - contextPath: Infoblox.ModifiedResponsePolicyZoneRules.View
      description: The view of the definition.
      type: string
    - contextPath: Infoblox.ModifiedResponsePolicyZoneRules.Zone
      description: The zone to which this rule belongs.
      type: string
    - contextPath: Infoblox.ModifiedResponsePolicyZoneRules.ReferenceID
      description: The reference ID of the rule.
      type: string
    description: Creates a substitute rule of the PTR record.
  - name: infoblox-create-srv-substitute-record-rule
    arguments:
    - name: name
      required: true
      description: The name for a record in FQDN format.
    - name: rp_zone
      required: true
      description: The zone to assign the rule.
    - name: comment
      description: Add a comment for this rule.
    - name: port
      required: true
      description: The port of the substitute rule of the SRV record. Can be 0 to
        65535 (inclusive).
    - name: priority
      required: true
      description: The priority of the substitute rule for the SRV Record. Can be
        0 to 65535 (inclusive).
    - name: target
      required: true
      description: The target of the substitute rule of the SRV record in FQDN format.
        This value can be in unicode format.
    - name: weight
      required: true
      description: The weight of the substitute rule of the SRV record. Can be 0 to
        65535 (inclusive).
    outputs:
    - contextPath: Infoblox.ModifiedResponsePolicyZoneRules.Name
      description: The rule name.
      type: string
    - contextPath: Infoblox.ModifiedResponsePolicyZoneRules.Disable
      description: Whether this rule is disabled.
      type: boolean
    - contextPath: Infoblox.ModifiedResponsePolicyZoneRules.Comment
      description: The comment for this rule.
      type: string
    - contextPath: Infoblox.ModifiedResponsePolicyZoneRules.Type
      description: The object type as used in Infoblox.
      type: string
    - contextPath: Infoblox.ModifiedResponsePolicyZoneRules.View
      description: The view of the definition.
      type: string
    - contextPath: Infoblox.ModifiedResponsePolicyZoneRules.Zone
      description: The zone to which this rule belongs.
      type: string
    - contextPath: Infoblox.ModifiedResponsePolicyZoneRules.ReferenceID
      description: The reference ID of the rule.
      type: string
    description: Creates a substitute rule of a SRV record.
  - name: infoblox-create-txt-substitute-record-rule
    arguments:
    - name: name
      required: true
      description: The name for a record in FQDN format.
    - name: rp_zone
      required: true
      description: The zone to assign the rule.
    - name: comment
      description: Add a comment for this rule.
    - name: text
      required: true
      description: Text associated with the record. To enter leading, trailing, or
        embedded spaces in the text, add quotes around the text to preserve the spaces.
    outputs:
    - contextPath: Infoblox.ModifiedResponsePolicyZoneRules.Name
      description: The rule name.
      type: string
    - contextPath: Infoblox.ModifiedResponsePolicyZoneRules.Disable
      description: Whether this rule is disabled.
      type: boolean
    - contextPath: Infoblox.ModifiedResponsePolicyZoneRules.Comment
      description: The comment for this rule.
      type: string
    - contextPath: Infoblox.ModifiedResponsePolicyZoneRules.Type
      description: The object type as used in Infoblox.
      type: string
    - contextPath: Infoblox.ModifiedResponsePolicyZoneRules.View
      description: The view of the definition.
      type: string
    - contextPath: Infoblox.ModifiedResponsePolicyZoneRules.Zone
      description: The zone to which this rule belongs.
      type: string
    - contextPath: Infoblox.ModifiedResponsePolicyZoneRules.ReferenceID
      description: The reference ID of the rule.
      type: string
    description: Create a substitute rule for a txt record.
  - name: infoblox-create-ipv4-substitute-record-rule
    arguments:
    - name: name
      required: true
      description: The name for a record in FQDN format.
    - name: rp_zone
      required: true
      description: The zone to assign the rule.
    - name: comment
      description: Add a comment for this rule.
    - name: ipv4addr
      required: true
      description: The IPv4 Address of the substitute rule.
    outputs:
    - contextPath: Infoblox.ModifiedResponsePolicyZoneRules.Name
      description: The rule name.
      type: string
    - contextPath: Infoblox.ModifiedResponsePolicyZoneRules.Disable
      description: Whether this rule is disabled.
      type: boolean
    - contextPath: Infoblox.ModifiedResponsePolicyZoneRules.Comment
      description: The comment for this rule.
      type: string
    - contextPath: Infoblox.ModifiedResponsePolicyZoneRules.Type
      description: The object type as used in Infoblox.
      type: string
    - contextPath: Infoblox.ModifiedResponsePolicyZoneRules.View
      description: The view of the definition.
      type: string
    - contextPath: Infoblox.ModifiedResponsePolicyZoneRules.Zone
      description: The zone to which this rule belongs.
      type: string
    - contextPath: Infoblox.ModifiedResponsePolicyZoneRules.ReferenceID
      description: The reference ID of the rule.
      type: string
    description: Create a substitute rule for an IPv4 rule.
  - name: infoblox-create-ipv6-substitute-record-rule
    arguments:
    - name: name
      required: true
      description: The name for a record in FQDN format.
    - name: rp_zone
      required: true
      description: The zone to assign the rule.
    - name: comment
      description: Add a comment for this rule.
    - name: ipv6addr
      required: true
      description: The IPv6 Address of the substitute rule.
    outputs:
    - contextPath: Infoblox.ModifiedResponsePolicyZoneRules.Name
      description: The rule name.
      type: string
    - contextPath: Infoblox.ModifiedResponsePolicyZoneRules.Disable
      description: Whether this rule is disabled.
      type: boolean
    - contextPath: Infoblox.ModifiedResponsePolicyZoneRules.Comment
      description: The comment for this rule.
      type: string
    - contextPath: Infoblox.ModifiedResponsePolicyZoneRules.Type
      description: The object type as used in Infoblox.
      type: string
    - contextPath: Infoblox.ModifiedResponsePolicyZoneRules.View
      description: The view of the definition.
      type: string
    - contextPath: Infoblox.ModifiedResponsePolicyZoneRules.Zone
      description: The zone to which this rule belongs.
      type: string
    - contextPath: Infoblox.ModifiedResponsePolicyZoneRules.ReferenceID
      description: The reference ID of the rule.
      type: string
    description: Creates a substitute of the IPv6 record rule.
  - name: infoblox-enable-rule
    arguments:
    - name: reference_id
      required: true
      description: The ID of the rule reference (could be extracted by running the
        search rules command).
    outputs:
    - contextPath: Infoblox.ModifiedResponsePolicyZoneRules.Disable
      description: Whether this rule is disabled.
      type: boolean
    - contextPath: Infoblox.ModifiedResponsePolicyZoneRules.Comment
      description: The rule comment.
      type: string
    - contextPath: Infoblox.ModifiedResponsePolicyZoneRules.Name
      description: The rule name.
      type: string
    - contextPath: Infoblox.ModifiedResponsePolicyZoneRules.ReferenceID
      description: The reference ID of the rule.
      type: string
    - contextPath: Infoblox.ModifiedResponsePolicyZoneRules.Zone
      description: The response policy zone to which this rule belongs.
      type: string
    - contextPath: Infoblox.ModifiedResponsePolicyZoneRules.View
      description: The view of the definition.
      type: string
    description: Disables a rule by its reference ID (reference ID could be extracted
      by running the searah rules command).
  - name: infoblox-disable-rule
    arguments:
    - name: reference_id
      required: true
      description: The ID of the rule reference (reference ID could be extracted by
        running the 'infoblox-search-rule' command).
    outputs:
    - contextPath: Infoblox.ModifiedResponsePolicyZoneRules.Disable
      description: Whether this rule is disabled.
      type: boolean
    - contextPath: Infoblox.ModifiedResponsePolicyZoneRules.Comment
      description: The rule comment.
      type: string
    - contextPath: Infoblox.ModifiedResponsePolicyZoneRules.Name
      description: The rule name.
      type: string
    - contextPath: Infoblox.ModifiedResponsePolicyZoneRules.ReferenceID
      description: The ID of the rule reference.
      type: string
    - contextPath: Infoblox.ModifiedResponsePolicyZoneRules.Zone
      description: The response policy zone to which this rule belongs.
      type: string
    - contextPath: Infoblox.ModifiedResponsePolicyZoneRules.View
      description: The view of the definition.
      type: string
    description: Disable a rule by its reference ID (reference ID could be extracted
      by running the 'infoblox-search-rule' command).
  - name: infoblox-get-object-fields
    arguments:
    - name: object_type
      required: true
      description: The Infoblox object type (can be retrieved by running the 'infoblox-list-response-policy-zone-rules'
        command).
    outputs:
    - contextPath: Infoblox.ObjectFields.ObjectType
      description: The Infoblox object type.
      type: string
    - contextPath: Infoblox.ObjectFields.SupportedFields
      description: The list of supported fields for this object.
      type: string
    description: Returns the object fields names which can be used in the search rules
      command.
  - name: infoblox-search-rule
    arguments:
    - name: object_type
      required: true
      description: The Infoblox object type (can be retrieved by running the 'infoblox-list-response-policy-zone-rules'
        command).
    - name: rule_name
      required: true
      description: 'The full rule name (usually the rule name followed by its zone.
        Example: name.domain.com)'
    - name: output_fields
      description: The fields to include in the return object (supported object fields
        can be retrieved by running the *infoblox-get-object-fields* command).
    outputs:
    - contextPath: Infoblox.RulesSearchResults.Name
      description: The rule name.
      type: string
    - contextPath: Infoblox.RulesSearchResults.ReferenceID
      description: The reference ID of the rule.
      type: string
    - contextPath: Infoblox.RulesSearchResults.View
      description: The view of the definition.
      type: string
    description: Searches a specific rule by its name.
  - name: infoblox-delete-rpz-rule
    arguments:
    - name: reference_id
      required: true
      description: The reference ID of the rule (reference ID can be retrieved by
        running the 'infoblox-search-rule' command).
    description: Deletes a rule.
  - name: infoblox-delete-response-policy-zone
    arguments:
    - name: reference_id
      required: true
      description: The reference ID of the rule (could be extracted by running the
        search rules command).
    description: Deletes a given response policy zone.
  - name: infoblox-create-a-record
    arguments:
    - name: name
      required: true
      description: The FQDN for the A record
    - name: ipv4addr
      required: true
      description: The IPv4 address for the record
    description: Create an A "Host' Record
  - name: infoblox-update-a-record
    arguments:
    - name: name
      required: true
      description: The FQDN for the A record
    - name: ipv4addr
      required: true
    - name: refid
      required: true
      description: The Reference Id for the record pull from get-ip
  - name: infoblox-get-refid
    arguments:
    - name: view
      description: The View inside Infoblox (Default is "default")
      defaultValue: default
    - name: host
      required: true
      description: Find the Ref ID of this Hostname
    - name: status
      description: The status of the host record.  Typically USED or UNUSED
      defaultValue: USED
    - name: domain
      required: true
      defaultValue: defense.local
    - name: ipadd
      required: true
      description: Host IP Address
    - name: deletes
      auto: PREDEFINED
      predefined:
      - "yes"
      - "no"
      description: Add Disconnected to the Deletes context
      defaultValue: "no"
    description: Return RefID on Records and  place in context GlobalProtect.Hosts
      (Adds, Updates, or Deletes)
  - name: infoblox-update-host-record
    arguments:
    - name: host
      required: true
      description: FQDN hostname
    - name: ipadd
      required: true
      description: IP Address to Update
    - name: refid
      required: true
      description: The Infoblox RefID.  (Get via infoblox-get-refid-by-host)
    description: Updates a host records IP address
  - name: infoblox-add-host-record
    arguments:
    - name: host
      required: true
      description: Host name to add
    - name: ipadd
      required: true
      description: IP Address to add
    description: Add a Host record to an empty IP
  - name: infoblox-delete-host-record
    arguments:
    - name: refid
      required: true
  dockerimage: demisto/python3:3.7.5.4583
  runonce: false
  subtype: python3
sourcemoduleid: Infoblox
